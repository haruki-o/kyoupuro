- SA_ans.cpp
  ・ 手順
  - 適当に盤面G2を生成する(入力された盤面Gとバーツ違う) O(N^2)
  - G2の1つのパーツを増やす、これで閉路になる(G < G2のパーツを選ぶ、余剰パーツを消すイメージ)
  - 閉路を解決するように1つ消す
  - 上2つをひたすら繰り返す
  ・ 難しそうな所
  - 辺を追加する
    - 全探索。最適な辺を記録しておく(最適 : 辺を追加し、変形後のパーツがG > G2となっている)
    - G2, parts2を変更
  - 辺を削除する
    - 閉路のpathを検出(訪れる頂点番号も確認したい)
    - 追加した辺からdfs -> 経路復元する O(N^2)
    - G2, parts2を変更
  ・ 実装
  - add_edge()
  - delete_edge(int sh, int sw)
    - 追加した辺と同じ場合、ran[]に頂点を保存しておいてランダムに選ぶ
  - parts, parts2[16] [0,N^2)
    - G,G2のそれぞれのパーツの個数
  - G, G2[N][N] [0,16)
    - 盤面のパーツの種類
  ・ 実際に動かしてみて
  - 追加した返と同じ所が削除されたらまずい
  - 以前消した辺と同じ辺を消してもダメ(追加するとき固定しているため)
  - 削除辺をランダムにしてもダメ -> 追加辺もランダムに選ぶ(all[5][]で同じscoの時ランダム)
  - add_edge()ときにG[N-1][N-1]に辺を追加してはいけない

  - なんか少ない時間でもG2は作れている -> 横軸time,縦軸成功確率を作る
  - (Q, time, p) -> Qケース回して成功確率p, 各ケースはtime秒, 全体でtime * Q秒
  - (Q, time, p) = 
  (100, 0.1, 83), (100, 0.01, 79), (100, 0.001, 34),
  (1000, 0.1, 846), (1000, 0.01, 821), (1000, 0.002, 616),
  (1000, 0.001, 376), (1000, 0.0001, 0)
  - (1000, 0.002, 616)でatcoder上で561ms 813個ずつ作れる.

  Gと同じパーツ数を持つG2ができたのでGを変形させてG2にする。
  ・ 手順
  - (0,0),(0,1),...,(N-1,0),(N-1,1),(N-2,1),...,(0,1), .. (0,2)のように左上から上下にうねうねと作っていく.
  - (0,N-2)と(0,N-1), (1,1)と(1,0),..は一緒に作る
  - 最後の2列( , N-2), ( , N-1)は(0,N-2),(0,N-1),(1,N-2),(1,N-1)と横方向に作っていく
  - (h,w)を作るときG2[h][w]のパーツを確認し、未完成部分のG[][]から同じパーツの座標(h',w')をあるだけ取得(O(N^2)し(h',w') -> (h,w)の最短を探す.
  - (h', w') -> (h,w)は, (h',w') -> (h',w) -> (h,w)と列を合わせて行を合わせる.
  - (h', w') -> (h'+dy[k], w'+dx[k])のとき予め(h'+dy[k], w'+dx[k])に何もない(G[][] = 0)パーツである必要がある

  ・計算量
  - G[vh][vw] = 0を満たす(vh,vw)は保持しておきたい
  - (h',w') -> (h, w)を決める関数
    - 未完成の(h',w')を全探索O(N^2)し、それぞれに対してマンハッタン距離を使いO(1)で求める. よってO(N^2)
  - (h,w)を作る関数
    - (h', w') -> (h, w)のルートをbfs -> 経路復元で求める
    - (h',w') -> (h, w)のとき1マスずつ行うと(vh,vw)は4回移動する。大体O((|h'-h| + |w'-w| * 4) <= O(N^2 * 4)
  - 上二つをN^2回繰り返す
    O(N^4)


  ・実装
  - _G = Gとする。(Gが複数のことがある)
  - _made_G[][] (bool) 作られたマスか
  - G[vh][vw] = 0を満たす(vh,vw)は保持しておきたい
  - (vh,vw)を動かすイメージ
  - P best_parts(h,w)
   - 上記の(_i, _j)を決める関数, 
   - パーツの形状はG2[_i][_j]から取得
  - find_best_route(_h, _w, h, w)
    - (_h, _w) -> (h, w)をbfs -> 経路復元
  - va_move(h,w)
    - (vh, vw) -> (h, w)する関数
    - _G,vh,vwを変更
  - move()
    - route[1]に(vh,vw)をおく(va_move()を呼び出す)
    - rotue[0]に(vh,vw)をずらす
    - route[0]にあった(_h,_w)がroute[1]に移る
  - set_parts(h,w)
    - 上記の(h,w)を作る関数
    - ここでbest_parts()を呼び出す
    - _route[]を定めるfind_best_route()を呼び出す
    - _route[]にしたがって(_h,_w) -> (h,w)を実際に実行する, move()を呼び出す 
  - set_3_3()
    - 右下の3 * 3を作る関数

・ あとからやりたい
   - 生成したG2がどのくらい他と同じなのか（同じだと生成した意味ない)

・完成品
  - (N, Q, 実行時間) = (6, 1000, 623ms), (10, 1000, 871ms), (10, 1000, 1717ms)
  Q = 2000でTLE
  Q = 1000で2.9秒以上は強制終了つけた。

  - (all_TIME_LIMIT, Q, sum) = (, 100, 136.05), (, 1000, 139.844)

  ・best_parts()のマンハッタン距離をbfsにした
    - (, 100, 136.014) -> 変わらない
  ・ route[]は階段状の方が良さそう
- dfs_ans.cpp
  - 中心からdfsしていく(むずそう)

